#!/bin/sh
# basic testsuite for ss/ssserv
set -e

# check for parameters
work="$1"
if [ -z "$work" ]
then
    echo "$0 <dir>"
    exit 1
fi

not()
{
    ("$@") && false || true
}


# prepare the directory
rm -rf "$work"
mkdir -p "$work"
cd "$work"

# checkin a new file
echo "- add"
echo test > test1.txt
ss add -c '' test1.txt
test \! -w test1.txt

echo "- add 2"
not ss add -c '' test1.txt 2> /dev/null

echo "- time check"
echo "rev 1" > timecheck
ss add -c '' timecheck
oldtime="`ss log -m1 timecheck | sed -ne 's/.* Date: \([^\/]*\)\/\([^\/]*\)\/\([^ ]*\)   Time: \([^.]*\)\.\(.*\)/20\3\/\2\/\1:\4:\5:00/p'`"

# checkout the file
echo "- checkout"
ss co test1.txt
test -w test1.txt

# checkin
echo "- checkin"
echo >> test1.txt
ss ci -c 'comment' test1.txt
test \! -w test1.txt

echo "- checkin 2"
echo > test2.txt
not ss ci -c '' test2.txt 2> /dev/null
rm test2.txt

echo "- checkin 3"
ss co test1.txt
VISUAL="false" not ss ci test1.txt 2> /dev/null
VISUAL="touch -t 197001010000" ss ci test1.txt

# get
echo "- get"
rm -f test1.txt
ss get test1.txt > /dev/null
test \! -w test1.txt

# recursive get
echo "- recursive get"
rm -f test1.txt
ss get . > /dev/null
test \! -w test1.txt

# history
echo "- history"
ss history test1.txt > /dev/null
ss history -m1 test1.txt | grep -q "^Comment: comment"

# diff
echo "- diff"
test -z "`ss diff test1.txt`"
ss co test1.txt
echo "new" >> test1.txt
ss diff -du test1.txt | grep -q "^+new";

# revert the file
echo "- revert"
ss revert -r test1.txt
test -w test1.txt

echo "- revert 2"
ss revert test1.txt
test \! -w test1.txt

echo "- revert 3"
ss co test1.txt
echo blabla > test1.txt
ss revert -a test1.txt
test -w test1.txt
ss revert test1.txt
test \! -w test1.txt

# status
echo "- status"
ss status test1.txt > /dev/null

# dir
echo "- dir"
ss dir . | grep -q "^test1.txt"
ss dir -a . > /dev/null

# label
echo "- label"
ss label -lalabel test1.txt
ss status test1.txt | grep -q "Last Label: *alabel"

# cat
echo "- cat"
ss cat test1.txt > /dev/null
ss cat -h test1.txt | grep -q "^==== ";

echo "- cat 2"
not ss cat test1.txt#0 2> /dev/null
not ss cat test1.txt#alabel 2> /dev/null
ss cat test1.txt#1 > /dev/null
not ss cat test1.txt@0 2> /dev/null
ss cat test1.txt@alabel > /dev/null

# go on with diff
echo "- diff 2"
echo "rev1" > difftest
ss add -c '' difftest
test -z "`ss diff difftest`"
test -z "`ss diff difftest#1`"
ss co difftest
echo "rev2" > difftest
ss diff difftest | sed -e '1d' > difftest1
ss diff difftest#1 | sed -e '1d' > difftest2
cmp -s difftest1 difftest2

echo "- diff2"
test -z "`ss diff2 difftest#1 difftest | sed -e '1d'`"
ss ci -c '' difftest
ss diff2 difftest#1 difftest#2 | sed -e '1d' > difftest1
cmp -s difftest1 difftest2
rm difftest1 difftest2
ss delete -f difftest

# go on with label
echo "- label 2"
echo "rev1" > labeltest
ss add -c '' labeltest
ss co labeltest
echo "rev2" > labeltest
ss ci -c '' labeltest
ss label -llabeltest labeltest#1
ss cat labeltest@labeltest | grep -q "^rev1$"
ss label -lnewlabel labeltest@labeltest
ss cat labeltest@newlabel | grep -q "^rev1$"
not ss label -llabeltext labeltest#1 2> /dev/null

echo "- label 3"
not ss label -l '1nvalid' labeltest@newlabel 2> /dev/null
ss label -l 'alph4num_3ric-la( la).' labeltest@newlabel
ss label -l newlabel 'labeltest@alph4num_3ric-la( la).'
ss rm labeltest

# delete
echo "- delete"
ss delete test1.txt
test \! -f test1.txt

echo "- delete 2 (requires AUTOREC)"
touch deltwice
not ss delete deltwice 2> /dev/null
ss add -c '' deltwice
ss co deltwice
not ss delete deltwice 2> /dev/null
ss delete -f deltwice
touch deltwice
ss add -c '' deltwice
ss delete deltwice 2> /dev/null

echo "- delete 3"
mkdir d3
touch d3/d3
ss add -c '' d3/d3
ss delete d3/d3
touch d3
not ss add -c '' d3 2> /dev/null

# now be bastard: trick delete to actually >remove< d3 and then check
# the -f flag even with AUTOREC enabled. Yes, it's a bug(tm).
echo "- delete 4"
chmod -w d3
ss delete d3
touch d3
ss add -c '' d3
not ss delete d3 2> /dev/null
ss delete -f d3

# recover
echo "- recover"
echo test > recover
ss add -c '' recover
ss delete recover
ss recover recover > /dev/null
expr "`cat recover`" = "test" > /dev/null
ss delete recover

# multiple add
echo "- multiple add"
touch test2.txt test3.txt
ss add -c 'multiple add' test2.txt test3.txt

# recursive add
echo "- recursive add"
mkdir temp
touch temp/test4.txt
expr "`ss add -c '' .`" = "adding ./temp/test4.txt" > /dev/null

# multiple checkout
echo "- multiple checkout"
ss co test2.txt test3.txt

# recursive checkout
echo "- recursive checkout"
expr "`ss co temp`" = "checking-out temp/test4.txt" > /dev/null

# multiple checkin
echo "- multiple checkin"
ss ci -c 'multiple checkin' test2.txt test3.txt

# recursive checkin
echo "- recursive checkin"
expr "`ss ci -c '' .`" = "checking-in ./temp/test4.txt" > /dev/null

echo "- recursive checkin 2"
touch test1.txt
expr "`ss ci -c '' .`" = "? ./test1.txt" > /dev/null
rm test1.txt

# multiple history
echo "- multiple history"
ss history . test2.txt test3.txt > /dev/null

# multiple diff
echo "- multiple diff"
ss co temp/test4.txt
echo "diff" >> temp/test4.txt
ss diff -du test2.txt test3.txt temp/test4.txt | grep -q "+diff"

# recursive diff
echo "- recursive diff"
ss diff -du . | grep -q "+diff"

echo "- recursive diff 2"
touch test5.txt
ss diff -du . | grep -q "+diff"
rm test5.txt

echo "- diff return status"
not ss diff -du temp/test4.txt > /dev/null
not ss diff -du . > /dev/null
ss revert -r temp/test4.txt
ss diff -du temp/test4.txt
ss diff -du .
touch remove
not ss diff -du .
rm remove

# multiple revert
echo "- multiple revert"
ss co test2.txt test3.txt
ss revert test2.txt test3.txt

# recursive revert
echo "- recursive revert"
expr "`ss revert .`" = "reverted ./temp/test4.txt" > /dev/null

# multiple status
echo "- multiple status"
ss status test2.txt test3.txt > /dev/null

# multiple dir
echo "- multiple dir"
ss dir test2.txt test3.txt > /dev/null

# multiple label
echo "- multiple label"
ss label -lanotherlabel test2.txt test3.txt
ss status test2.txt | grep -q "Last Label: *anotherlabel"

# multiple cat
echo "- multiple cat"
ss cat test2.txt test3.txt > /dev/null
ss cat -h test2.txt test3.txt > /dev/null

# multiple delete
echo "- multiple delete"
ss delete test2.txt test3.txt

# recursive delete
echo "- recursive delete"
expr "`ss delete temp`" = "deleting temp/test4.txt" > /dev/null
test \! -d temp

# multiple recover
echo "- multiple recover"
touch recover1 recover2
ss add -c '' recover1 recover2
ss delete recover1 recover2
ss recover recover1 recover2 > /dev/null
ss delete recover1 recover2

# check file consistency across calls
fcheck()
{
    cp "$1" "$1.tmp"

    # add the file
    ss add -c '' "$1"
    ss label -lfcheck "$1"

    # re-get
    rm -f "$1"
    ss get "$1" > /dev/null
    cmp -s "$1" "$1.tmp"

    # modify and revert
    ss co "$1"
    cmp -s "$1" "$1.tmp"
    echo line >> "$1"
    ss revert "$1"
    cmp -s "$1" "$1.tmp"

    # modify and checkin
    ss co "$1"
    echo line >> "$1"
    cp "$1" "$1.tmp2"
    ss ci -c '' "$1"
    cmp -s "$1" "$1.tmp2"

    # fetch old versions by number
    ss cat "$1#1" > "$1.tmp3"
    cmp -s "$1.tmp" "$1.tmp3"

    # fetch by label
    ss cat "$1@fcheck" > "$1.tmp3"
    cmp -s "$1.tmp" "$1.tmp3"

    rm "$1.tmp" "$1.tmp2" "$1.tmp3"
    ss delete "$1"
}

echo "- empty file consistency"
touch empty
fcheck empty

echo "- text file consistency"
echo line1 > text
echo line2 >> text
fcheck text

# check time only at the end, as sourcesafe resolution seems to be limited
# to minutes.... parse the log date to avoid time-skew issues.
# Add "20" to the year to fix broken log date format...
echo "- time check 2"
ss co timecheck
echo "rev 2" > timecheck
ss ci -c '' timecheck
curtime="`ss log -m1 timecheck | sed -ne 's/.* Date: \([^\/]*\)\/\([^\/]*\)\/\([^ ]*\)   Time: \([^.]*\)\.\(.*\)/20\3\/\2\/\1:\4:\5:00/p'`"
expr "`ss cat timecheck@$oldtime`" = "`ss cat timecheck#1`" > /dev/null
expr "`ss cat timecheck@$curtime`" = "`ss cat timecheck#2`" > /dev/null
ss delete timecheck

echo "- relative update"
mkdir reltest
touch reltest/test
ss add -c '' reltest/test
cd reltest
ss up ..
expr "`ss up ..`" = "" > /dev/null

# finished
echo "completed"
exit 0
